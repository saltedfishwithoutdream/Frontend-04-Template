学习笔记
#### 一、文法的分类
乔姆斯基体系
0型文法：无限制文法或短语结构文法，包括所有文法
   ?::=?
1型文法：上下文相关文法
   ?<A>?::=?<B>?
2型文法：上下文无关文法
   <A>::=?
3型文法：正规文法
   <A>::=<A>?没有<A>::=?<A>   左结合
   或者
   <A>::=?<A>没有<A>::=<A>?   右结合

js大体上属于上下文无关文法，大部分表达式属于正则文法，当然也有一些特例
2**1**2  是右结合的，<A>::=?<A>

get在不知道后面的字符时不能确定其语义
get a {return 1}  获取属性a的值
get: 1  get本身作为属性，其值为1

#### 二、产生式
产生式： 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句

巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

终结符： 最终在代码中出现的字符
非终结符：还可以通过推导成为非终结符或终结符的字符

举个例子：
<句子>::=<主语><谓语>
<主语>::=<代词><名词>
<代词>::=你|我|他
<名词>::=张三|工人|英语
<谓语>::=<动词><直接宾语>
<动词>::=是|学习
<直接宾语>::=<代词><名词>

上面的产生式中用<>括起来的是非终结符，否则是终结符

#### 三、0.1 + 0.2
JS的基础类型Number，遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。
1位表示符号，0表示正，1表示负
11位表示指数，2^11 = 2048
52位表示尾数（小数部分）
符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

Number.MIN_VALUE和Number.MAX_VALUE
指数部分的长度是11个二进制，即指数部分能表示的最大值是 2047（2^11-1）
取中间值进行偏移，用来表示负指数，也就是说指数e的范围是[-1023,1024],其中
(a) 当e = -1023时，表示±0或非规格浮点数，
当我们要表示一个小于2^-1023的数时，我们就无法用(-1)^符号位 * 1.xx...xx * 2^指数位，来表示它，
只能(-1)^符号位 * =0.00..00xx..xx * 2^-1023来表示，这种表示方式，但这种方式表示的数也有极限，
我们用0.0...0(51个0)1 * 2 ^ -1023 表示，即2 ^ -1075，用0.0...0(50个0)1 * 2 ^ -1023表示最小值（Number.MIN_VALUE）,即2 ^ -1074
(b)当e = 1024时，表示Infinity无穷大
(c)当e等于其他值时，表示一般数字，其中能表示的最大值是1.1(52个1) * 2 ^ 1023， 1.1(52个1)转换为十进制数为1.9999999999999998
1.9999999999999998 * 2 ^ 1023 = 1.7976931348623157e+308，这个值就是Number.MAX_VALUE

IEEE754 规定，有效数字第一位默认总是1（对非规格化浮点数不适用） 。因此，在表示精度的位数前面，还存在一个 “隐藏位” ，固定为 1 ，但它不保存在 64 位浮点数之中。也就是说，有效数字总是 1.xx...xx 的形式，其中 xx..xx 的部分保存在 64 位浮点数之中，最长为52位 。
所以，JavaScript 提供的有效数字最长为 53 个二进制位，其内部实际的表现形式为：
(-1)^符号位 * 1.xx...xx * 2^指数位（规格化浮点数）


Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER
这意味着，JavaScript 能表示并进行精确算术运算的整数范围为：[-2^53-1，2^53-1]，
即从最小值 -9007199254740991 到最大值 9007199254740991 之间的范围 。
对应于js中的Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER

超过这个范围的整数，js也可以计算，但是不能保证其精度
如9007199254740991 + 2 = 9007199254740991 + 1 = 9007199254740992，明显不对



基于上面的标准，就可以解释0.1 + 0.2为什么不等于0.3了
0.1 = 1.1001100110011001100110011001100110011001100110011010 * 2^-4
0.2 = 1.1001100110011001100110011001100110011001100110011010 * 2^-3
0.1 + 0.2时，先将0.1的指数-4变成-3
0.1 = 0.1100110011001100110011001100110011001100110011001101 * 2^-3

0.1 + 0.2 = 
  0.1100110011001100110011001100110011001100110011001101 * 2^-3
+ 1.1001100110011001100110011001100110011001100110011010 * 2^-3
=10.0110011001100110011001100110011001100110011001100111 * 2^-3
= 1.0011001100110011001100110011001100110011001100110100 * 2^-2
转换为十进制为0.30000000000000004

下面介绍IEEE754规范的舍入方案
最近偶数原则（必须指定保留的小数位）--
最近原则：是"损失的精度最小"原则.
偶数原则：当向上和向下损失的精度一样时，将其舍入为偶数，
以我们熟悉的十进制为例：
1.255保留一位小数，会变成1.2还是1.3？
1.255与1.2相差0.55，与1.3相差0.45，所以结果是1.3
1.255保留两位小数，会变成1.25还是1.26？
1.255与1.25相差0.005，与1.26也相差0.05，这种情况下最近原则失效，采用偶数原则，结果是1.26

根据这个原则我们来说明下面的问题
let a = 2 ^ 53 = 9007199254740992
a + 1 = 9007199254740992
a + 2 = 9007199254740994
a + 3 = 9007199254740996
a + 4 = 9007199254740996
a + 5 = 9007199254740996
a + 6 = 9007199254740998
a + 7 = 9007199254741000
a + 8 = 9007199254741000
a + 9 = 9007199254741000
...

前面说过，在进行加法运算时，需要把小一点的数的指数变得和大数一样
那么 2 ^ 53 + 1 = 1 * 2 ^ 53 + 0.0(52个0)1 * 2 ^ 53
显然0.0(52个0)1的最后一位是超过了精度的，需要舍入，根据偶数原则，0.0(52个0)1 * 2 ^ 53舍入后成为0.0(52个0) * 2 ^ 53 = 0
所以a + 1 = 9007199254740992

2 ^ 53 + 3  = 1 * 2 ^ 53 + 0.0(51个0)11 * 2 ^ 53
最后一个1是超精度的，需要舍入，根据偶数原则0.0(51个0)11 * 2 ^ 53舍入后变为0.0(50个0)10 * 2 ^ 53 = 4所以
a + 3 = 9007199254740996，其他同理

再看一个问题
let b = 2 ^ 54 = 18014398509481984
b + 1/2 = 18014398509481984
b + 3/4/5 = 18014398509481988
b + 6/7/8/9/10 = 18014398509481990

这里后两位是需要丢弃的，
1的最后几位是001，与000相差1，与100相差3，所以变成000（最近原则）
2的最后几位是010，与000相差2，与100也相差2，但000的最低保留位是偶数，所以变成000（偶数原则）
3的最后几位是011，与000相差3，与100相差1，所以变成100（最近原则）
4的最后几位是100，无需舍入
5的最后几位是101，与100相差1，与1000相差3，所以变成100
6的最后几位是110，与100相差2，与1000相差2，但1000的最低保留位是偶数，所以变成1000
7的最后几位是111，与100相差3，与1000相差1，所以变成1000
8的最后几位是1000，无需舍入
9的最后几位是1001，与1000相差1，与1100相差3，所以变成1000
10的最后几位是1010，与1000相差2，与1100相差3，但1000的最低保留位是偶数，所以变成1000


#### 四、对字符串用UTF8编码
1. 字符串的unicode码长度与字符串的length属性
   对于a = '𠮷'
   直观感受a的长度是1
   但是我们打印a.length，值确实2
   这是因为js内部字符以UTF-16格式存储，但'𠮷'去占了32位，需要两个'UTF16'表示
   因此如果要获取字符串的真实长度，需要先判断每个字符占用了几个'UTF16'

2. unicode码如何转换为UTF8
   ASCII码只需要8位就可以表示，所以直接使用
   超过127的就需要多位表示了
   规则如下
   左边uincode码范围         右边utf8编码
   0000 0000 - 0000 007f                                                0xxxxxxx
   0000 0080 - 0000 07ff                                       110xxxxx 10xxxxxx  
   0000 0800 - 0000 ffff                              1110xxxx 10xxxxxx 10xxxxxx
   0001 0000 - 001f ffff                     11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
   0020 0000 - 03ff ffff            111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   0400 0000 - 7fff ffff   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

   超过127的unicode码转UTF8时，前面一位前面1的个数表示需要几位表示，后面每位以10开头

   具体转换代码见index.html


#### 五、参考名词
图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。

图灵机（Turing machine）：又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。

静态和动态语言： https://www.cnblogs.com/raind/p/8551791.html

强类型： 无隐式转换

弱类型： 有隐式转换

协变与逆变： https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html


### 六、命令式和声明式 https://zhuanlan.zhihu.com/p/115135935
声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。
命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。
举个简单的例子，假设我们想让一个数组里的数值翻倍。

我们用命令式编程风格实现，像下面这样：

var numbers = [1,2,3,4,5]

var doubled = []

for(var i = 0; i < numbers.length; i++) {

  var newNumber = numbers[i] * 2
  doubled.push(newNumber)

}
console.log(doubled) //=> [2,4,6,8,10]
我们直接遍历整个数组，取出每个元素，乘以二，然后把翻倍后的值放入新数组，每次都要操作这个双倍数组，直到计算完所有元素。


而使用声明式编程方法，我们可以用 Array.map 函数，像下面这样：

var numbers = [1,2,3,4,5]

var doubled = numbers.map(function(n) {

  return n * 2
})
console.log(doubled) //=> [2,4,6,8,10]


一般命令式编程语句分为5个层级：
Atom--Identifer,Literal
Expression--Atom,Operator,Punctuator(符号)
Statement--Expression,Keyword,Punctuator
Structure--Function,Class,process,Namespace
Program--Program,Module,Package,Libr ary




