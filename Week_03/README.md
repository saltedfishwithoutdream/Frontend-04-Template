学习笔记
#### 一、字典树
1. 字典树是什么（引用自百度百科）
   又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

2. 主要的操作查找和插入
   插入：当我们想要插入一个单词，需要遍历单词的每个字符，从根节点的子节点开始取匹配每个字符，如果存在则继续匹配下一个字符，如果不存在，则以该字符为key创建一个新的节点，遍历完成后，在最后一个表示终结的节点，并在节点中保存该单词对应的信息。本例保存的是该单词出现的次数，如果字典树对应的是真正的英汉词典，那么终结节点保存的就是该单词的汉语解释。如果字典树对应的是搜索引擎，那么终结节点保存的就是，该词条对应的每一条搜索结果。

   查找：相对于插入，查找就是一个比较简单的问题了，同样是遍历单词的每个节点，逐层匹配，如果最终能匹配到最后一个字符，且最后一个字符有终结符子节点，则查找成功，否则失败。查找成功后，便可获取到该单词对应的具体信息。

#### 二、KMP
1. KMP是什么
   KMP是一个字符串的模式匹配算法，即在一个文本串中匹配一个模式串，并返回其出现的位置。
   KMP有两种形态，一种基于有限自动机（DFA），一种是基于部分匹配表（PMT），但是它们的核心思想是一致的--利用匹配失败后的信息，尽可能少的减少模式串与主串的匹配次数，已达到快速匹配的目的。

2. 基于DFA的算法
   （1）定义若干个状态，规则如下，0为初始态，每正确匹配一个状态状态值+1，故有pattern.length + 1（0 - pattern.length）种状态，其中0是初态，pattern.length是终态。
   （2）接下来是创建DFA表格，表示当处于某个状态时，遇到字符集中的某个字符，应该跳转到哪个状态。
   这里有一个潜台词，当我们处于j状态时，表示前面的j-1个字符都是匹配成功的，那么当我们匹配第j个字符时，要么匹配成功，状态变为j+1，要么匹配不成功，状态回退到0到j-1中的某个状态。
   举例说明：模式串为ABABAC，字符集是ABC

         0   1   2   3   4   5    状态（输入第j个字符前的状态）
         A   B   A   B   A   C    pattern
    A    1   1   3   1   5   1    (状态转换表，在当前状态下输入字符集中的每个字符得到的不同状态，
    B    0   2   0   4   0   4     前提是前j-1个字符输入的都匹配了  
    C    0   0   0   0   0   6    )

    模式串长度为6，状态时0-6
    dfa.A[3] = 1表示在状态3下输入的下一个字符是A，会将状态转移（回退）到1。
    
    观察dfa.A[0],dfa.B[1],dfa.A[2],dfa.B[3],dfa.A[4],dfa.C[5]，它们的每一次匹配都是正确的，所以状态会递增，直到终态。
    其他的匹配都是错误的，因此状态都会回退，问题是回退是否有什么规律。

    分析状态回退的规律。
    当匹配到第j个字符时，发现不匹配，在不移动文本串的情况下，模式串至少向右移动一位，那么就需要考虑1到j-1位能到达哪种状态，
    如pattern ABABAC，txt  ABACABAABABAC
    
    ABACABAABABAC    
    ABABAC
    j=3时不匹配，此时i = 3，那么pattern右移（不知道移几位，但是至少要移一位）
    因为每一步都匹配正确才能达到最大状态值，匹配错误只能回退，那么，匹配错误的情况一定在dfa表格中出现过（动态规划），
    如j=3时，第1到j-1位是BA，dfa.B[0] = 0, dfa.A[0] = 1，所以应该退回到状态1，并且由前面的推导关系我们不难得出，
    当j=4时，第1到j-1位是BAB，dfa.B[0] = 0, dfa.A[0] = 1，dfa.B[1] = 2，回退到状态2
    也就是说每当j++时，我们可以仅仅通过上次j不匹配时回退的状态，推断出本次不匹配需要回退的状态
    let x = 0 // 回退状态初始化
    x = dfa[pattern[j]][x] // 这一步是回退状态的推导式
    j++

    得到回退状态后，就需要将x的状态列，复制到j的状态列
    for (let c = 0; c < cLength; c++) {
        dfa[chars[c]][j] = dfa[chars[c]][x] // 匹配失败的情况
    }
    但是有一种情况是例外，就是匹配正确的情况
    dfa[pattern[j]][j] = j + 1 // 修正匹配正确的情况

    至此，dfa创建成功

    （3）根据dfa表格进行匹配
    有了dfa表格，匹配算法就水到渠成了
    如果pattern[j] === txt[i], i++, j++
    否则状态回退，j = dfa[txt[i]][j], i++

3. 基于PMT的算法
   理解了基于DFA的算法之后，这个就相对简单了。
   构造PMT表格，网上一般称为next表
   next[j]表示模式串的1到j-1的后缀和模式串0到j-1的前缀的最长匹配数，
   ABABAC的next数组是[-1, 0, 0, 1, 2, 3]，注意next[0]=-1主要是为了编码方便设置的初始值

   重点是如何推导出next数组，前面dfa第j列的值，可以通过前j-1列的值推导出来，同样next[j]的值也可以通过next[0]到next[j-1]推导出来
   假设next[j] = k，这表示pattern[0到k-1]=pattern[j-k到j-1]，再此基础上，如果pattern[k] = pattern[j]，那么
   pattern[0到k]=pattern[j-k到j]，即next[j+1] = k+1，反之，如果pattern[k] != pattern[j]，就需要减小k的值，k = next[k]，
   这是一个递归的过程，知道pattern[k] = pattern[j]，或者k=-1，这其实和dfa的状态回退有异曲同工之妙。
   while (j < pattern.length - 1) {
        if (k === -1 || pattern[j] === pattern[k]) {
            ++j
            ++k
            next[j] = k
        } else {
            k = next[k]
        }
    }

   next构造完成后，匹配过程就比较简单了

#### 三、Wildcard
Wildcard是要求模式串与文本串完全匹配，且模式传中包含*和?
*代表0个或多个任意字符
?代表一个任意字符

基于*号的特性，我们将*分为两种，最后一个和其他，这么分的理由是：前面的*应该尽可能早的匹配字符，最后一个*用于最终的兜底，前面剩下的所有字符都可以用*匹配上。也就是说在匹配的前提下，前面的*要尽可能少的匹配字符，最后的*尽可能多的匹配字符。

有了这个基本思想，还要考虑被*分隔的最前的字符和最后的字符。
前面的字符要从前面开始匹配，最后的字符要从最后开始匹配。所以最终模式串在形式上药被划分为如下结构
xxx          (*xxx){0-n}                *            xxx
不带*的首字符   中间每个*和后面带的字符       最后一个*     不带*末尾字符

匹配步骤
a.匹配不带*的首字符
b.匹配中间每个*和后面带的字符（这里需要注意的是正则的lastIndex属性的使用）
c.匹配不带*末尾字符（最后一个*仅仅作为一个分隔符，不需要单独处理）
上面的步骤仅仅针对一般情况，边界情况，需要特殊处理。


#### 三、Proxy与双向绑定
proxy就是在我们访问对象前添加了一层拦截，可以过滤很多操作或者添加一些行为
映射到现实生活中，租房子时我们遇到的中介就是一层代理，他们拦截了我们的租房请求，向我们收取中介费（代理添加的操作），
他们会带着我们找到房子(响应租房请求），但是还有一些黑中介，拿钱不办事（不响应租房请求）。

双向绑定用到了proxy的特性，在get中收集依赖，在set中触发get中收集的函数

#### 四、拖拽
1. 名词解释
   在拖拽物上按下鼠标不放，然后移动鼠标，拖拽物会随着鼠标一起移动，松开鼠标后拖拽物不在随着鼠标移动。
2. 实现
   首先在拖拽元素上监听mousedown事件，绑定一个函数，函数体内在document上监听mousemove，mouseup事件，
   在mousemove上绑定的函数会记录鼠标位置，以此为依据移动拖拽体的位置
   在mouseup上绑定的函数，主要是移除mousemove，mouseup事件。
   Q：为什么要在按下鼠标之后监听mousemove，mouseup事件？
   A：逻辑上，我们要在鼠标按下以后拖动物体，而不是只要鼠标移动就能拖动物体。我们也可以通过添加一个拖拽开关，来实现，当按下鼠标设置为可拖动，松开鼠标设置为不可拖动。我们需要一直监听这个事件，执行相应的函数，这回损耗一部分性能。

   Q：为什么不在拖拽物上监听mousemove，mouseup事件?
   A：这是为了防止鼠标在移动过快的情况下，鼠标移出拖拽物外时，出现“拖断”的现象，除此之外，现代浏览器上在document上监听，会产生一个捕捉鼠标的效果，鼠标移出浏览器，还是能监听到。

3. 在正常流里拖拽--将一个div块在文字中间拖拽
   需要使用range API
   
   